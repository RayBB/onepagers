<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OL Quickstatements</title>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jq-web@0.6.0/jq.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/deep-diff@1/dist/deep-diff.min.js"></script>
    <!-- Notyf -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <style>
        @keyframes loadingDots {
            0%, 20% { content: "." }
            40% { content: ".." }
            60%, 100% { content: "..." }
        }
        .loading-text::after {
            content: "...";
            display: inline-block;
            animation: loadingDots 1.5s infinite;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-8">
    <div id="app">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-900 mb-8">OL Quickstatements</h1>
            
            <div class="mb-4">
                <label for="presets" class="block text-sm font-medium text-gray-700 mb-2">Preset Examples</label>
                <select 
                    id="presets" 
                    v-model="selectedPreset" 
                    @change="applyPreset"
                    class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                    <option value="">Select a preset...</option>
                    <option v-for="(preset, key) in presets" :key="key" :value="key">
                        {{ preset.label }}
                    </option>
                </select>
            </div>

            <textarea 
                v-model="statements"
                class="w-full h-32 p-4 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-4"
                placeholder="Enter your quickstatements here..."
            ></textarea>

            <div v-if="parsedStatements" class="bg-white p-4 rounded-lg shadow">
                <h2 class="text-xl font-semibold mb-4">Parsed Results:</h2>
                <div v-for="(transforms, authorId) in parsedStatements" :key="authorId" class="mb-4">
                    <h3 class="font-medium text-gray-800 flex items-center gap-2">
                        <span>{{ authorId }}</span>
                        <span v-if="!authorData[authorId]" class="ml-2 text-sm text-gray-500">Loading<span class="loading-text"></span></span>
                        <span v-else class="ml-2">- {{ authorData[authorId].name }}</span>
                        <button 
                            v-if="authorData[authorId]"
                            @click="copyFetchCommand(authorId)"
                            class="ml-2 px-2 py-1 text-sm bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-md flex items-center gap-1"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                            </svg>
                            Copy Fetch
                        </button>
                    </h3>

                    <div class="grid grid-cols-2 gap-4 mt-2">
                        <!-- Transformations Column -->
                        <div class="space-y-2">
                            <h4 class="font-medium text-gray-700">Transformations:</h4>
                            <ul class="ml-4">
                                <li v-for="transform in transforms" :key="transform" class="text-gray-600">
                                    {{ transform }}
                                </li>
                            </ul>
                        </div>

                        <!-- Diff Column -->
                        <div class="space-y-2">
                            <h4 class="font-medium text-gray-700">Changes:</h4>
                            <div v-if="getAuthorDiff(authorId)" class="space-y-1">
                                <div v-for="change in getAuthorDiff(authorId)" :key="change.path.join('.')" 
                                     class="text-sm font-mono">
                                    <span class="text-gray-500">{{ change.path.join('.') }}:</span>
                                    <span class="text-red-500 line-through mr-1">{{ change.lhs }}</span>
                                    <span class="text-green-500">{{ change.rhs }}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                </div>
            </div>

            <!-- Documentation Section -->
            <div class="max-w-4xl mx-auto mt-12 bg-white p-6 rounded-lg shadow">
                <h2 class="text-2xl font-bold text-gray-900 mb-6">Documentation & FAQs</h2>
                
                <div class="space-y-6">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">How does it work?</h3>
                        <p class="text-gray-600">
                            This tool uses <a href="https://stedolan.github.io/jq/" class="text-blue-600 hover:underline" target="_blank">jq</a> 
                            for JSON transformations. Each line in the quickstatements follows the format:
                            <code class="block bg-gray-100 p-2 mt-2 rounded font-mono text-sm">
                                [Author ID]|[jq transformation]
                            </code>
                        </p>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Can I share quickstatements via URL?</h3>
                        <p class="text-gray-600">
                            Yes! You can pass quickstatements via the URL using the <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">statements</code> parameter. For example:
                            <code class="block bg-gray-100 p-2 mt-2 rounded font-mono text-sm break-all">
                                ?statements=OL1234567A|.name%20%3D%20%22New%20Author%20Name%22
                            </code>
                            Make sure to URL encode the statements when sharing.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Common jq Operations</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li>Set a value: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">.name = "New Name"</code></li>
                            <li>Add to array: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">.alternate_names += ["New Name"]</code></li>
                            <li>Delete a field: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">del(.field_name)</code></li>
                        </ul>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Working with Nested JSON</h3>
                        <p class="text-gray-600 mb-2">
                            Access nested fields using dot notation:
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li>Set nested value: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">.remote_ids.wikidata = "Q12345"</code></li>
                            <li>Delete nested value: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">del(.remote_ids.wikidata)</code></li>
                        </ul>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Array Operations</h3>
                        <p class="text-gray-600 mb-2">
                            There are several ways to modify arrays:
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li>Delete by index: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">del(.alternate_names[0])</code></li>
                            <li>Delete last item: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">del(.alternate_names[-1])</code></li>
                            <li>Delete by value: <code class="bg-gray-100 px-1 py-0.5 rounded font-mono">.alternate_names -= ["Name to Remove"]</code></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue
        
        createApp({
            data() {
                return {
                    statements: this.getStatementsFromUrl() || [
                        'OL1394244A|.name = "New Author Name"',
                        'OL1394244A|.remote_ids.wikidata = "Q1104369"',
                        'OL1394244A|del(.personal_name)',
                        'OL1394245A|.name = "New Author Name"'
                    ].join('\n'),
                    authorData: {},
                    jq: null,
                    selectedPreset: '',
                    presets: {
                        setWikidata: {
                            label: 'Set author Wikidata ID',
                            value: 'OL1234567A|.remote_ids.wikidata = "Q12345"'
                        },
                        addAltName: {
                            label: 'Add alternative name',
                            value: 'OL1234567A|.alternate_names += ["Alternative Author Name"]'
                        },
                        removeAuthorName: {
                            label: 'Remove author name',
                            value: 'OL1234567A|del(.name)'
                        }
                    },
                    notyf: null
                }
            },
            created() {
                this.initializeNotyf();
                this.initializeJq();
            },
            computed: {
                parsedStatements() {
                    if (!this.statements.trim()) return null;

                    return this.statements
                        .split('\n')
                        .filter(line => line.trim())
                        .reduce((result, line) => {
                            let [authorId, transform] = line.split('|');
                            authorId = authorId.trim();
                            transform = transform.trim();
                            
                            return {
                                ...result,
                                [authorId]: [
                                    ...(result[authorId] || []),
                                    transform
                                ]
                            };
                        }, {});
                }
            },
            methods: {
                initializeNotyf() {
                    this.notyf = new Notyf();
                },
                async initializeJq() {
                    this.jq = await jq;
                },
                transformAuthorData(authorId) {
                    if (!this.jq || !this.parsedStatements) return null;

                    const authorData = this.authorData[authorId];
                    if (!authorData) return null;

                    const jqStatements = this.parsedStatements[authorId];
                    let transformedData = JSON.parse(JSON.stringify(authorData));

                    // Apply each transformation sequentially
                    for (const statement of jqStatements) {
                        transformedData = this.jq.json(transformedData, statement);
                    }

                    return transformedData;
                },
                async fetchAuthorData(authorId) {
                    try {
                        // Check if we already have the data cached
                        if (this.authorData[authorId]) {
                            console.log('Cached author data:', authorId, this.authorData[authorId]);

                            if (this.parsedStatements && this.parsedStatements[authorId]) {
                                console.log('Transforms for author:', authorId, this.parsedStatements[authorId]);
                            }
                            return this.authorData[authorId];
                        }

                        const response = await fetch(`https://openlibrary.org/authors/${authorId}.json`)
                        if (!response.ok) throw new Error('Failed to fetch author data')
                        const data = await response.json()
                        this.authorData[authorId] = data
                        return data
                    } catch (error) {
                        console.error('Error fetching author data:', error)
                        this.notyf.error(`Failed to fetch data for ${authorId}`);
                        return null
                    }
                },
                getAuthorDiff(authorId) {
                    const originalData = this.authorData[authorId];
                    const transformedData = this.transformAuthorData(authorId);
                    
                    if (!originalData || !transformedData) return null;
                    
                    return DeepDiff.diff(originalData, transformedData)
                        ?.filter(change => ['E', 'N', 'D', 'A'].includes(change.kind))
                        ?.map(change => {
                            if (change.kind === 'A') {
                                return {
                                    ...change,
                                    path: [...change.path, change.index],
                                    lhs: change.item.kind === 'D' ? change.item.lhs : undefined,
                                    rhs: change.item.kind === 'N' ? change.item.rhs : undefined
                                };
                            }
                            return {
                                ...change,
                                lhs: change.kind === 'N' ? undefined : (change.kind === 'D' ? change.lhs : change.lhs),
                                rhs: change.kind === 'D' ? undefined : (change.kind === 'N' ? change.rhs : change.rhs)
                            };
                        });
                },
                applyPreset() {
                    if (this.selectedPreset && this.presets[this.selectedPreset]) {
                        this.statements = this.presets[this.selectedPreset].value;
                    }
                },
                getStatementsFromUrl() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const statements = urlParams.get('statements');
                    return statements ? decodeURIComponent(statements) : null;
                },
                copyFetchCommand(authorId) {
                    const transformedData = this.transformAuthorData(authorId);
                    if (!transformedData) return;

                    const fetchCommand = `fetch('https://openlibrary.org/authors/${authorId}.json', {
    method: 'PUT',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(${JSON.stringify(transformedData)})
})`;

                    navigator.clipboard.writeText(fetchCommand)
                        .then(() => {
                            this.notyf.success('Fetch command copied to clipboard!');
                        })
                        .catch(err => {
                            console.error('Failed to copy:', err);
                            this.notyf.error('Failed to copy fetch command');
                        });
                }
            },
            watch: {
                parsedStatements: {
                    immediate: true,
                    async handler(newStatements) {
                        if (!newStatements) return;
                        
                        for (const authorId of Object.keys(newStatements)) {
                            await this.fetchAuthorData(authorId);
                        }
                    }
                }
            }
        }).mount('#app')
    </script>
</body>
</html>
