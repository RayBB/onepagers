<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OL Quickstatements</title>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jq-web@0.6.0/jq.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/deep-diff@1/dist/deep-diff.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen p-8">
    <div id="app">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-900 mb-8">OL Quickstatements</h1>
            <textarea 
                v-model="statements"
                class="w-full h-32 p-4 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-4"
                placeholder="Enter your quickstatements here..."
            ></textarea>

            <div v-if="parsedStatements" class="bg-white p-4 rounded-lg shadow">
                <h2 class="text-xl font-semibold mb-4">Parsed Results:</h2>
                <div v-for="(transforms, authorId) in parsedStatements" :key="authorId" class="mb-4">
                    <h3 class="font-medium text-gray-800">{{ authorId }}</h3>
                    
                    <div v-if="authorData[authorId]" class="mt-2 p-3 bg-gray-50 rounded">
                        <p><span class="font-medium">Name:</span> {{ authorData[authorId].name }}</p>
                        <p v-if="authorData[authorId].birth_date">
                            <span class="font-medium">Birth Date:</span> {{ authorData[authorId].birth_date }}
                        </p>
                    </div>

                    <ul class="ml-4 mt-2">
                        <li v-for="transform in transforms" :key="transform.path" class="text-gray-600">
                            {{ transform }}
                        </li>
                    </ul>
                    <div v-if="getAuthorDiff(authorId)" class="mt-2 space-y-1">
                        <div v-for="change in getAuthorDiff(authorId)" :key="change.path.join('.')" 
                             class="text-sm font-mono">
                            <span class="text-gray-500">{{ change.path.join('.') }}:</span>
                            <span class="text-red-500 line-through mr-1">{{ change.lhs }}</span>
                            <span class="text-green-500">{{ change.rhs }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue
        
        createApp({
            data() {
                return {
                    statements: `OL1394244A|.name = "New Author Name"
                                OL1394244A|.description = "New Author description"
                                OL1394244A|del(.personal_name)
                                OL1394245A|.name = "New Author Name"`,
                    authorData: {},
                    jq: null
                }
            },
            async created() {
                this.jq = await jq;
            },
            computed: {
                parsedStatements() {
                    if (!this.statements.trim()) return null;

                    return this.statements
                        .split('\n')
                        .filter(line => line.trim())
                        .reduce((result, line) => {
                            let [authorId, transform] = line.split('|');
                            authorId = authorId.trim();
                            transform = transform.trim();
                            
                            return {
                                ...result,
                                [authorId]: [
                                    ...(result[authorId] || []),
                                    transform
                                ]
                            };
                        }, {});
                }
            },
            methods: {
                transformAuthorData(authorId) {
                    if (!this.jq || !this.parsedStatements) return null;

                    const authorData = this.authorData[authorId];
                    if (!authorData) return null;

                    const jqStatements = this.parsedStatements[authorId];
                    let transformedData = JSON.parse(JSON.stringify(authorData));

                    // Apply each transformation sequentially
                    for (const statement of jqStatements) {
                        transformedData = this.jq.json(transformedData, statement);
                    }

                    return transformedData;
                },
                async fetchAuthorData(authorId) {
                    try {
                        // Check if we already have the data cached
                        if (this.authorData[authorId]) {
                            console.log('Cached author data:', authorId, this.authorData[authorId]);

                            if (this.parsedStatements && this.parsedStatements[authorId]) {
                                console.log('Transforms for author:', authorId, this.parsedStatements[authorId]);
                            }
                            return this.authorData[authorId];
                        }

                        const response = await fetch(`https://openlibrary.org/authors/${authorId}.json`)
                        if (!response.ok) throw new Error('Failed to fetch author data')
                        const data = await response.json()
                        this.authorData[authorId] = data
                        return data
                    } catch (error) {
                        console.error('Error fetching author data:', error)
                        return null
                    }
                },
                getAuthorDiff(authorId) {
                    const originalData = this.authorData[authorId];
                    const transformedData = this.transformAuthorData(authorId);
                    
                    if (!originalData || !transformedData) return null;
                    
                    return DeepDiff.diff(originalData, transformedData)
                        ?.filter(change => ['E', 'N', 'D'].includes(change.kind))
                        ?.map(change => ({
                            ...change,
                            // For new fields, set lhs to undefined
                            // For deleted fields, use the lhs value
                            lhs: change.kind === 'N' ? undefined : (change.kind === 'D' ? change.lhs : change.lhs),
                            // For new fields, use rhs directly
                            // For deleted fields, set rhs to undefined
                            rhs: change.kind === 'D' ? undefined : (change.kind === 'N' ? change.rhs : change.rhs)
                        }));
                }
            },
            watch: {
                parsedStatements: {
                    immediate: true,
                    async handler(newStatements) {
                        if (!newStatements) return;
                        
                        for (const authorId of Object.keys(newStatements)) {
                            await this.fetchAuthorData(authorId);
                        }
                    }
                }
            }
        }).mount('#app')
    </script>
</body>
</html>
